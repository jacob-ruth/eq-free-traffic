function trafficDiffMapBifurcation()
h = 1.2;                % optimal velocity parameter
len = 60;               % length of the ring road
numCars = 60;           % number of cars

tskip = 300;            % times for evolving
delta = 2000;

stepSize = .0005;        % step size for the secant line approximation
delSigma = 1e-7;     % delta sigma used for finite difference of F
delv0 = 1e-7;        % delta v0 used for finite difference of F
tolerance = 5e-4;    % tolerance for Newton's method

options = odeset('AbsTol',10^-8,'RelTol',10^-8); % ODE 45 options
foptions = optimset('TolFun',1e-10, 'ObjectiveLimit', 1e-7); % fsolve options

%% load diffusion map data
load('jacobOutput','joutput885');
load('jacobOutput2','j2output885');
load('jacobOutput3', 'j3output885');
load('jacobOutput7', 'j7output885');
load('saveData','trafficOutput');
load('repsaves', 'trafficOutput2');
loadedData = [joutput885 j2output885 j3output885 j7output885];
loadedData = [getHeadways(loadedData(1:60,:)); loadedData(61:end, :)];
load('moreData','goodData');
allData =  [goodData loadedData];
%% align the maximum of each wave at the last position
allData = shiftMaxVel(allData,20);                         % initially move the max to 30 to avoid indexing errors
for iFun = 1:size(allData,2)                            % max headway will always be at 60
    allData(:,iFun) = alignMaxVel(allData(:,iFun),numCars, 20);
end
allVel = allData(numCars + 1:end, :);
allData = allData(1:numCars, :);
numEigvecs = 1;                                         % number of eigenvectors to return
[evecs, evals, eps] = runDiffMap(allData,numEigvecs);   % run the diffusion map
% testLift(evecs, evals, eps, allData);
% plot sigma vs eigenvector 1
figure;
hold on;
scatter(std(allData), evecs,'b.');
xlabel('\sigma');
ylabel('\Phi_1');



%% initialize secant continuation
steps = 10;                                % number of steps to take around the curve
bifDif = zeros(2,steps);                       % array to hold the bifurcation values

% initialize the first reference state
load('save884','trafficOutput','v0');
ref_2A = [getHeadways(trafficOutput(1:60)); trafficOutput(61:end)];
ref_2 = getHeadways(trafficOutput(1:60));
ref_2 = shiftMax(ref_2, 20);
ref_2 = alignMax(ref_2,20);
ref_2A = shiftMaxVel(ref_2A,  20);
ref_2A = alignMaxVel(ref_2A, 60, 20);
v0_base2 = v0;

% initialize the second reference state
load('885ref','trafficOutput','v0');
ref_1 = getHeadways(trafficOutput(1:60));
ref_1 = shiftMax(ref_1, 20);
ref_1 = alignMax(ref_1,20);
v0_base1 = v0;
ref_1A = [getHeadways(trafficOutput(1:60)); trafficOutput(61:end)];
ref_1A = shiftMaxVel(ref_1A,  20);
ref_1A = alignMaxVel(ref_1A, 60, 20);

sigma_1 = diffMapRestrict(ref_1,evals,evecs,allData,eps);      %initial sigma values for secant line approximation
sigma_2 = diffMapRestrict(ref_2,evals,evecs,allData,eps);
% F(allData,0.01007,0.882,evecs,evals,eps, ref_1A)

guesses = bifDif;
%% pseudo arc length continuation
figure;
hold on;
plot([v0_base1 v0_base2],[sigma_1; sigma_2], 'r-');
drawnow;
for iEq=1:steps
    fprintf('Starting iteration %d of %d \n', iEq, steps);
    w = [sigma_2 - sigma_1 ; v0_base2 - v0_base1];          % slope of the secant line
    newGuess = [sigma_2; v0_base2] + stepSize *(w/norm(w)); % first guess on the secant line
    plot([v0_base1 v0_base2],[sigma_1; sigma_2], 'g-');
    drawnow;
    guesses(:,iEq) = newGuess;
    guessSteps = zeros(2, 20);
    %% initialize Newton's method
    u = newGuess;
    scatter(newGuess(2), newGuess(1), 'ro');
    drawnow;
    first = true;                       % mimic a do-while loop
    k=1;                            	% Newton's method counter
    %% Newton and that other guy's method
        while(first ||(norm(invD*[f;neww])>tolerance && k < 20))
            first = false;
            fprintf('\t Newton iteration: %d \n', k);
            f = F(allData,u(1),u(2),evecs,evals,eps, ref_2A);                                % calculcate the function to zero
            neww = w(1)*(u(1)-newGuess(1)) + w(2)*(u(2) - newGuess(2));
            f
            ww(1)*(u(1)-newGuess(1)) + W(2)*(u(2) - newGuess(2))
            Df = jacobian(allData, u(1), u(2), w, evecs, evals, eps, ref_2A);                    % find the jacobian
            invD = Df^(-1);
            u = u - invD*[f;neww]; 
            scatter([newGuess(2); u(2)],[newGuess(1); u(1)], 'b*');
            drawnow;
            % perform the Newton step
            guessSteps(:,k+1) = u;
            k = k + 1;
        end
    %% alternate Newton's method using fsolve
    %   u = fsolve(@(u)FW(u,allData,w,newGuess,evecs,evals,eps, ref_2A), newGuess,foptions)
    
    bifDif(:,iEq) = u;                                            % save the new solution
    
    % interpolate and plot the new value on sigma vs eigenvector 1
    %     sig = interp1(evecs,std(allData),bifDif(1,iEq));
    %     scatter(sig, bifDif(1,iEq), 'r*');
    %     drawnow;
    
    %% reset the values for the arc length continuation
    ref_1A = ref_2A;
    sigma_1 = sigma_2;
    v0_base1 = v0_base2;
    v0_base2 = u(2);
    sigma_2 = u(1);
    [~,ref_2A] = ler(u(1),allData,tskip + delta,u(2),evecs,evals,eps,ref_1A);  % find the new reference state
    ref_2A = [getHeadways(ref_2A(1:60)) ;ref_2A(61:end)];
    ref_2A = shiftMaxVel(ref_2A, 20);
    ref_2A = alignMaxVel(ref_2A, 60,20);
end

%% plot the bifurcation diagram
figure;
scatter(bifDif(2,:),bifDif(1,:),'*');
xlabel('v0');
ylabel('\Phi_1');
% interpolate back to the standard deviation values
sig = interp1(evecs,std(allData),bifDif(1,:));
sig2 = interp1(evecs, std(allData), guesses(1,:));

load('microBif.mat', 'bif');
%% plot results vs good results
figure;
hold on;
scatter(bif(end,:), std(bif(1:numCars,:)),50,'b.');
scatter(bifDif(2,:),sig, 'r*');
scatter(guesses(2,:),sig2, 'b*');

% plot the bifurcation diagram using standard deviation coordinates
figure;
scatter(bifDif(2,:),sig);
title('interpolated sigmas');
xlabel('v0');
ylabel('\Phi_1');

%% functions

%% function to zero for fsolve
% u         - the current value of (sigma, v0) that we're trying to find
%               with Newton's method
% ref       - the most recent reference state
% W         - the slope of the secant line for arc length continuation
% newGuess  - the first guess on the secant line for arc length
%               continuation
%
% RETURNS:
% fw    - the functions F and w evaluated at these parameters
    function fw = FW(u,ref,W,newGuess,evecs,evals,lereps, refS)
        fw = zeros(2,1);
        fw(1) = F(ref,u(1),u(2),evecs,evals,lereps, refS);
        fw(2) = W(1)*(u(1)-newGuess(1)) + W(2)*(u(2) - newGuess(2));
    end

%% lift, evolve, restrict
% sigma - the current value of the std, used to seed the lifting
% ref   - a reference state, used to seed the lifting
% t     - the duration to evaluate the lifted parameters
% p     -  parameter which will degrade the accuracy of the lifting
%               operator.  Should be kept at p = 1 by default.
% v0    - the optimal velocity parameter for this state
% RETURNS:
% sigma     - the std. of the headways after restricting has occured
% new_state - the final state of the evolution, which can be used as a
%               future reference state
    function [sigma,new_state, sigma2, new_state2] = ler(newval,orig,t,v0,eigvecs,eigvals,lereps,refS, tReference)
        lifted = diffMapLift(newval, eigvecs,eigvals,lereps, orig, allVel, refS);
        liftedPosns = cumsum(lifted(1:60));
        lifted = [liftedPosns ; lifted(61:end)];
        [tevo,evo] = ode45(@microsystem,[0 t],lifted, options,v0);
        if (nargin >= 9)
            [t2,evo2] = ode45(@microsystem,[0 tReference],evo(end,1:2*numCars)',options,v0);
            evo2Cars = evo2(end, 1:numCars)';
            evo2Cars = shiftMax(getHeadways(evo2Cars), 20);
            evo2Cars = alignMax(evo2Cars,20);
            sigma2 = diffMapRestrict(evo2Cars,eigvals,eigvecs, orig, lereps);
        end
        evoCars = evo(end, 1:numCars)';
        evoCars = shiftMax(getHeadways(evoCars), 20);
        evoCars = alignMax(evoCars,20);
        sigma = diffMapRestrict(evoCars, eigvals, eigvecs, orig, lereps);
        if(nargout >= 2)
            new_state = evo(end,1:2*numCars)';
        end
        if(nargout == 4)
            new_state2 = evo2(end,1:2*numCars)';
        end
    end

%% Finite Difference Quotient
%  ref - reference state to base the lifting
%  sigma - the current value of the std. at which point to approximate
%       the time derivative
%  v0 - the velocity parameter for this state
%  RETURNS:
%  dif - the difference which approximates the time derivative
    function dif = F(ref, sigma,v0,eigvecs,eigvals,lereps, refS)
        [r0, ~, r1] = ler(sigma, ref, tskip, v0, eigvecs,eigvals,lereps, refS, delta);
        dif = (r1-r0)/delta;
    end

%% Jacobian for newton's method
% ref - The previous reference state used to compute F.
% sigma - the current value of sigma
% v0 - the velocity parameter for this state
% w - the secant direction
% J- The Jacobian, which will be given by
% | F_sigma    F_v0  |
% | w_sigma    w_vo  |
    function J = jacobian(ref, sigma, v0,w,eigvecs,eigvals,lereps, rS)
        J = zeros(2);
        unchanged = F(ref, sigma, v0,eigvecs,eigvals,lereps, rS);
        J(1,1) = (F(ref, sigma + delSigma, v0,eigvecs,eigvals,lereps, rS) - unchanged)/delSigma;
        J(1,2) = (F(ref, sigma,v0 + delv0,eigvecs,eigvals,lereps, rS) - unchanged)/delv0;
        J(2,:) = w';
    end

%% lifting operator
% s 	-   the target std. for this state
% p     -   parameter which will degrade the accuracy of the lifting
%           operator.  Should be kept at p = 1 by default.
% hways -   headways of the cars at a reference state
% v0    -   the goal velocity at this state
% RETURNS:
% new   -   the lifted vector of cars and their positions. The cars
%           will be reset to new positions with the first car centered
%            at 0, and with headways that will give the desired std. of
%            s.  The cars' new velocities will be given directly by the
%            optimal velocity function.
    function new = lift(s, p, hways, v0)
        del = p * s/std(hways) * (hways - mean(hways)) + mean(hways);
        new = zeros(length(hways)*2,1);
        for iLift=2:length(hways)
            new(iLift) = mod(sum(del(1:iLift-1)),len);
        end
        hways = getHeadways(new(1:length(hways)));
        for iLift=1:length(hways)
            new(iLift+length(hways)) = optimalVelocity(hways(iLift), v0);
        end
    end

%% optimal velocity function given in paper
%    h         -  a parameter to represent the optimal velocity of the
%               	car
%    headway   - the distance between this car and the car ahead of it
%    v0        - ideal goal speed of each driver
%    returns:
%    v         - the optimal velocity of this car, who will speed or slow to try
%                   to meet it
    function v = optimalVelocity(headway,v0)
        v = v0 * (tanh(headway - h) + tanh(h));
    end

%% function to calculate headways of car vector
%  v   - column vector of the cars' positions
%  returns:
%  hways - column vector of cars' headways
    function hways = getHeadways(v)
        futureCars = circshift(v,[-1,0]);
        hways = mod(futureCars - v, len);
    end

%% function to circshift max to beginning
    function c = shiftMax(hways, center)
        if(nargin>1)
            shift = center + 1;
        else
            shift = 1;
        end
        [~, maxH] = max(hways,[],1);  % locate the max headway for each data point
        c = zeros(size(hways));
        
        % align all of the headways with the max in the front
        for iCar = 1:length(maxH)
            c(:,iCar) = circshift(hways(:,iCar), [-maxH(iCar)+shift,0]);
        end
    end
    function c = shiftMaxVel(hways, center)
        if(nargin>1)
            shift = center + 1;
        else
            shift = 1;
        end
        [~, maxH] = max(hways(1:numCars,:),[],1);  % locate the max headway for each data point
        c = zeros(size(hways));
        
        % align all of the headways with the max in the front
        for iCar = 1:length(maxH)
            c(1:numCars,iCar) = circshift(hways(1:numCars,iCar), [-maxH(iCar)+shift,0]);
            c(numCars+1:end, iCar) = circshift(hways(numCars+1:end,iCar), [-maxH(iCar)+shift,0]);
        end
    end

%% ODE that governs individual cars
% Governs the movement of the individual cars (microvariables)
% ~         - dummy parameter for time, to allow use in ode45
% params    - a column vector of the distribution of the cars and their
%               velocities, of size 2*numCars.  The position of car i
%               and its velocity are given at num params(i),
%               params(i + numcars)
%
    function u = microsystem(~,colCars, v0)
        invT = 1.7;
        headways = getHeadways(colCars(1:numCars));
        
        u = zeros(2*numCars,1);
        u(1:numCars,1) = colCars(numCars+1:2*numCars,1);
        u(numCars+1:2*numCars,1) = invT*(optimalVelocity(headways,v0) - colCars(numCars+1:2*numCars,1));
    end

    function [maxinds, maxvals] = getTop3(hways)
        [maxhw,maxind] = max(hways,[],1);
        ind1 = mod(maxind-2,numCars)+1;
        ind3 = mod(maxind,numCars)+1;
        maxinds = [ind1 ; maxind ; ind3];
        maxvals = [hways(ind1) ; maxhw ; hways(ind3)];
    end
    function plotMacroTraj(t, evo, numPoints, str)
        allTimePoints = linspace(0,t, numPoints);
        evoPoints = interp1(t, evo, allTimePoints);
        evoHways = getHeadways(evoPoints(:,1:numCars)');
        evosteve = zeros(size(evoHways,2),1);
        for iSteve = 1:size(evoHways,2)
            evoHways(:,iSteve) = shiftMax(evoHways(:,iSteve),30);
            evoHways(:,iSteve) = alignMax(evoHways(:,iSteve),30);
            evosteve(iSteve) = diffMapRestrict(evoHways(:,iSteve),evals,evecs,allData,eps);
        end
       scatter(evoPoints, evosteve, str);
    end
end